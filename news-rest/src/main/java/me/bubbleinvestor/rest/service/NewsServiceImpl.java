package me.bubbleinvestor.rest.service;

import lombok.extern.slf4j.Slf4j;
import me.bubbleinvestor.model.NewsEntity;
import me.bubbleinvestor.model.Result;
import me.bubbleinvestor.rest.repository.NewsRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.WorkQueueProcessor;
import reactor.core.scheduler.Schedulers;

@Service
@Slf4j
public class NewsServiceImpl implements NewsService {
    private final NewsRepository newsReository;

    @Autowired
    public NewsServiceImpl(NewsRepository newsReository) {
        this.newsReository = newsReository;
    }

    @Override
    public Mono<Result> save(Mono<NewsEntity> monoNews) {
//        monoNews.map(newsEntity -> {
//            if (newsEntity.getId() != null) {
//                log.info("############: id is autogenerated uuid ############");
//                newsEntity.setId(UUID.randomUUID().toString());
//            }
//            this.newsReository.save(newsEntity);
//            return true;
//        }).subscribe(aBoolean -> {
//            System.out.println("Result is " + (aBoolean ? "SUCCESS" : "FAILURE"));
//        }).dispose();
//
//        return Mono.just(Boolean.TRUE);

//        Flux<String> bridge = Flux.push(sink -> {
//            myEventProcessor.register(
//                    new SingleThreadEventListener<String>() { (1)
//
//                        public void onDataChunk(List<String> chunk) {
//                            for(String s : chunk) {
//                                sink.next(s); (2)
//                            }
//                        }
//
//                        public void processComplete() {
//                            sink.complete(); (3)
//                        }
//
//                        public void processError(Throwable e) {
//                            sink.error(e); (4)
//                        }
//                    });
//        });


        Flux.range(1, 5).publishOn(Schedulers.parallel()).subscribe(i -> log.info(String.valueOf(i)));

        WorkQueueProcessor<Integer> processor = WorkQueueProcessor.create("TestWorkQueueProcessor", 10000);
//        processor.
        Flux.push(sink -> {

        });

        return Mono.fromFuture(monoNews.map(newsEntity -> {
            this.newsReository.save(newsEntity);
            return true;
        }).map(aBoolean -> {
            log.info("Result is " + (aBoolean ? "SUCCESS" : "FAILURE"));
            return Result.builder().result(aBoolean).build();
        }).toFuture());

//        return Mono.just(Boolean.TRUE);
    }

    @Override
    public Mono<NewsEntity> update(NewsEntity news) {
        return null;
    }

    @Override
    public Mono<NewsEntity> findOne(String id) {
        log.info("############: searching id:" + id + "  ############");
        return this.newsReository.findOne(id);
    }


    @Override
    public Mono<Boolean> delete(String id) {
        return null;
    }
}
